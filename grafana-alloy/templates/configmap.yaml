{{- if .Values.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-alloy-config
  labels:
    {{- include "grafana-alloy.labels" . | nindent 4 }}
data:
  config.alloy: |
{{- if .Values.alloyConfig.content }}
{{- .Values.alloyConfig.content | nindent 4 }}
{{- else }}
    logging {
      level  = "info"
      format = "logfmt"
    }

    {{- if .Values.alloyConfig.podLogs.enabled }}
    discovery.kubernetes "pods" {
      role = "pod"
      selectors {
        role  = "pod"
        field = "spec.nodeName=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
      }
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action        = "replace"
        target_label  = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        action        = "replace"
        target_label  = "node_name"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "app"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "job"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_component"]
        target_label  = "component"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_service", "__meta_kubernetes_pod_label_service"]
        regex         = "^;*([^;]+)(;.*)?$"
        target_label  = "service"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_workflowName"]
        regex         = "(.+)"
        target_label  = "workflowName"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_workflowVersion"]
        regex         = "(.+)"
        target_label  = "workflowVersion"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "__path__"
        separator     = "/"
        replacement   = "/var/log/pods/*$1/*.log"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_id"]
        action        = "replace"
        target_label  = "container_runtime"
        regex         = "^(\\S+):\\/\\/.+$"
        replacement   = "$1"
      }
    }

    local.file_match "pod_logs" {
      path_targets = discovery.relabel.pod_logs.output
    }

    loki.source.file "pod_logs" {
      targets    = local.file_match.pod_logs.targets
      forward_to = [loki.process.pod_logs.receiver]
    }

    loki.process "pod_logs" {
      stage.match {
        selector = "{namespace=\"loki\",container=~\"promtail|alloy\"}"
        action   = "drop"
      }

      stage.drop {
        older_than          = "1h"
        drop_counter_reason = "log_too_old"
      }

      stage.cri {}

      stage.labels {
        values = {
          stream = "",
        }
      }

      stage.label_drop {
        values = ["filename", "flags"]
      }

      stage.static_labels {
        values = {
          cluster  = {{ .Values.clusterName | quote }},
          exporter = "grafana-alloy",
        }
      }

      stage.replace {
        expression = "\\x1b\\[[0-9;]*m"
        replace    = ""
      }

      stage.regex {
        expression = "(?i)(?:^|[\\s\"'\\[{(,:=])(?P<level>\\b(?:trace|debug|dbg|trc|verbose|info|inf|information|notice|informational|warn|warning|wrn|error|err|fail|failure|severe|exception|critical|crit|fatal|ftl|panic|emerg|alert)\\b)(?:[\\s\"'\\]}),.:=]|$)"
      }

      stage.labels {
        values = {
          level = "",
        }
      }

      stage.match {
        selector = "{namespace=\"nginx-encrypted-ingress\",container=\"controller\"}"
        
        stage.regex {
          expression = "^\\S+ \\S+ \\S+ \\[[^\\]]+\\] \"(?P<verb>\\S+) (?P<uri>\\/[^\\s\\?\"]+)(?:\\?\\S*)? (?P<http_version>[^\"]+)\" (?P<status>\\d{3}) \\d+ \"[^\"]*\" \"[^\"]*\" \\d+ [\\d.]+ \\[(?P<destination>[^\\]]+)\\]"
        }

        stage.labels {
          values = {
            verb         = "",
            uri          = "",
            status       = "",
            http_version = "",
            destination  = "",
          }
        }
      }

      forward_to = [loki.relabel.normalize_level.receiver]
    }

    loki.relabel "normalize_level" {
      forward_to = [loki.write.endpoints.receiver]

      rule {
        source_labels = ["level"]
        regex         = "(?i)\\s*(debug|dbg|trace|verbose|trc)\\s*"
        target_label  = "level"
        replacement   = "debug"
        action        = "replace"
      }

      rule {
        source_labels = ["level"]
        regex         = "(?i)\\s*(info|information|notice|informational|inf)\\s*"
        target_label  = "level"
        replacement   = "info"
        action        = "replace"
      }

      rule {
        source_labels = ["level"]
        regex         = "(?i)\\s*(warn|warning|wrn)\\s*"
        target_label  = "level"
        replacement   = "warning"
        action        = "replace"
      }

      rule {
        source_labels = ["level"]
        regex         = "(?i)\\s*(err|error|fail|failure|severe|exception)\\s*"
        target_label  = "level"
        replacement   = "error"
        action        = "replace"
      }

      rule {
        source_labels = ["level"]
        regex         = "(?i)\\s*(crit|critical|fatal|panic|emerg|alert|ftl|crt)\\s*"
        target_label  = "level"
        replacement   = "critical"
        action        = "replace"
      }

      rule {
        action        = "lowercase"
        source_labels = ["level"]
        target_label  = "level"
      }
    }
    {{- end }}

    {{- if or .Values.alloyConfig.podLogs.enabled .Values.alloyConfig.events.enabled }}
    loki.write "endpoints" {
      {{- range $idx, $endpoint := .Values.loki.endpoints }}
      endpoint {
        url = {{ $endpoint.url | quote }}
        {{- if $endpoint.basicAuth }}
        {{- if $endpoint.basicAuth.envVar }}
        headers = {
          "Authorization" = "Basic " + env({{ $endpoint.basicAuth.envVar | quote }}),
        }
        {{- end }}
        {{- end }}
      }
      {{- end }}
    }
    {{- end }}

    {{- if .Values.alloyConfig.events.enabled }}
    loki.source.kubernetes_events "k8s_events" {
      forward_to = [loki.relabel.rename_namespace.receiver]
      log_format = "json"
      job_name   = "kubernetes-events"
    }

    loki.relabel "rename_namespace" {
      forward_to = [loki.process.add_event_labels.receiver]
      
      rule {
        source_labels = ["namespace"]
        action        = "replace"
        target_label  = "event_namespace"
      }
    }

    loki.process "add_event_labels" {
      stage.static_labels {
        values = {
          cluster  = {{ .Values.clusterName | quote }},
          exporter = "grafana-alloy",
        }
      }

      stage.json {
        expressions = {
          event_message   = "msg",
          event_reason    = "reason",
          event_type      = "type",
          event_count     = "count",
          event_kind      = "kind",
          event_host      = "sourcehost",
          event_component = "sourcecomponent",
        }
      }

      stage.labels {
        values = {
          event_reason    = "",
          event_type      = "",
          event_kind      = "",
          event_namespace = "",
          event_host      = "",
        }
      }

      stage.label_keep {
        values = ["job","cluster","exporter","level","event_message","event_reason","event_type","event_kind","event_namespace","event_host"]
      }

      forward_to = [loki.write.endpoints.receiver]
    }
    {{- end }}

    {{- if and .Values.alloyConfig.metrics.enabled .Values.prometheusRemoteWrite.enabled }}
    discovery.kubernetes "pods_metrics" {
      role = "pod"
    }

    discovery.relabel "pods_metrics" {
      targets = discovery.kubernetes.pods_metrics.targets

      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }

      rule {
        source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "job"
      }
    }

    prometheus.scrape "pods" {
      targets         = discovery.relabel.pods_metrics.output
      forward_to      = [prometheus.relabel.filter_metrics.receiver]
      scrape_interval = "1m"
      scrape_timeout  = "10s"
    }

    prometheus.relabel "filter_metrics" {
      {{- if .Values.prometheusRemoteWrite.enabled }}
      forward_to = [{{ range $idx, $endpoint := .Values.prometheusRemoteWrite.endpoints }}{{ if $idx }}, {{ end }}prometheus.remote_write.endpoint_{{ $idx }}.receiver{{ end }}]
      {{- end }}

      rule {
        target_label = "cluster"
        replacement  = {{ .Values.clusterName | quote }}
      }

      {{- if .Values.prometheusRemoteWrite.metricsFilter.enabled }}
      rule {
        source_labels = ["__name__"]
        regex         = {{ .Values.prometheusRemoteWrite.metricsFilter.regex | quote }}
        action        = "keep"
      }
      {{- end }}
    }
    {{- end }}

    {{- if .Values.prometheusRemoteWrite.enabled }}
    {{- range $idx, $endpoint := .Values.prometheusRemoteWrite.endpoints }}
    prometheus.remote_write "endpoint_{{ $idx }}" {
      endpoint {
        url = {{ $endpoint.url | quote }}
        
        {{- if $endpoint.queueConfig }}
        queue_config {
          max_samples_per_send = {{ $endpoint.queueConfig.maxSamplesPerSend }}
          batch_send_deadline  = {{ $endpoint.queueConfig.batchSendDeadline | quote }}
          min_shards           = {{ $endpoint.queueConfig.minShards }}
          max_shards           = {{ $endpoint.queueConfig.maxShards }}
          capacity             = {{ $endpoint.queueConfig.capacity }}
        }
        {{- end }}

        {{- if $endpoint.sigv4 }}
        {{- if $endpoint.sigv4.enabled }}
        sigv4 {
          region = {{ $endpoint.sigv4.region | quote }}
        }
        {{- end }}
        {{- end }}
      }

      {{- if $endpoint.externalLabels }}
      external_labels = {
        {{- range $key, $value := $endpoint.externalLabels }}
        {{ $key }} = {{ $value | quote }},
        {{- end }}
      }
      {{- end }}
    }
    {{- end }}
    {{- end }}
    {{- if and .Values.alloyConfig.beyla.enabled .Values.prometheusRemoteWrite.enabled }}
    beyla.ebpf "default" {
      debug = true

      attributes {
        instrument {
          name = ".*"
          
          kubernetes {
            namespace = ".*"
          }
        }
      }
      discovery {
        services {
          kubernetes {
            namespace = {{ .Values.alloyConfig.beyla.namespace | default ".*" | quote }}
          }
        }
      }
      output {
        metrics = [otelcol.exporter.prometheus.to_prometheus.input]
        {{- if and .Values.alloyConfig.traces.enabled .Values.tempo.enabled }}
        traces = [{{ range $idx, $endpoint := .Values.tempo.endpoints }}{{ if $idx }}, {{ end }}{{ if eq ($endpoint.protocol | default "grpc") "http" }}otelcol.exporter.otlphttp.tempo_{{ $idx }}.input{{ else }}otelcol.exporter.otlp.tempo_{{ $idx }}.input{{ end }}{{ end }}]
        {{- end }}
      }
    }
    otelcol.exporter.prometheus "to_prometheus" {
      forward_to = [
        {{- range $idx, $endpoint := .Values.prometheusRemoteWrite.endpoints }}
        prometheus.remote_write.endpoint_{{ $idx }}.receiver,
        {{- end }}
      ]
    }
    {{- end }}

    {{- if and .Values.alloyConfig.traces.enabled .Values.tempo.enabled }}
    otelcol.receiver.otlp "default" {
      grpc {
        endpoint = "0.0.0.0:4317"
      }
      http {
        endpoint = "0.0.0.0:4318"
      }
      output {
        traces = [otelcol.processor.batch.default.input]
      }
    }

    otelcol.processor.batch "default" {
      timeout = "5s"
      send_batch_size = 8192
      output {
        {{- if .Values.alloyConfig.traces.k8sMetadata.enabled }}
        traces = [otelcol.processor.k8sattributes.default.input]
        {{- else if .Values.alloyConfig.traces.healthCheckFilter.enabled }}
        traces = [otelcol.processor.filter.health_check.input]
        {{- else }}
        traces = [otelcol.processor.attributes.add_cluster.input]
        {{- end }}
      }
    }

    {{- if .Values.alloyConfig.traces.k8sMetadata.enabled }}
    otelcol.processor.k8sattributes "default" {
      extract {
        metadata = [
          {{- range $idx, $attr := .Values.alloyConfig.traces.k8sMetadata.extract }}
          {{ $attr | quote }},
          {{- end }}
        ]
      }

      pod_association {
        source {
          from = "connection"
        }
      }

      output {
        {{- if .Values.alloyConfig.traces.healthCheckFilter.enabled }}
        traces = [otelcol.processor.filter.health_check.input]
        {{- else }}
        traces = [otelcol.processor.attributes.add_cluster.input]
        {{- end }}
      }
    }
    {{- end }}

    {{- if .Values.alloyConfig.traces.healthCheckFilter.enabled }}
    otelcol.processor.filter "health_check" {
      error_mode = "ignore"
      traces {
        span = [
          {{- range $idx, $route := .Values.alloyConfig.traces.healthCheckFilter.routes }}
          "attributes[\"http.route\"] == \"{{ $route }}\"",
          {{- end }}
        ]
      }
      output {
        traces = [otelcol.processor.attributes.add_cluster.input]
      }
    }
    {{- end }}

    otelcol.processor.attributes "add_cluster" {
      action {
        key    = "cluster"
        value  = {{ .Values.clusterName | quote }}
        action = "upsert"
      }
      output {
        {{- $outputs := list }}
        {{- range $idx, $endpoint := .Values.tempo.endpoints }}
        {{- if eq ($endpoint.protocol | default "grpc") "http" }}
        {{- $outputs = append $outputs (printf "otelcol.exporter.otlphttp.tempo_%d.input" $idx) }}
        {{- else }}
        {{- $outputs = append $outputs (printf "otelcol.exporter.otlp.tempo_%d.input" $idx) }}
        {{- end }}
        {{- end }}
        {{- if and .Values.alloyConfig.traces.spanMetrics.enabled .Values.prometheusRemoteWrite.enabled }}
        {{- $outputs = append $outputs "otelcol.connector.spanmetrics.default.input" }}
        {{- end }}
        {{- if and .Values.alloyConfig.traces.serviceGraph.enabled .Values.prometheusRemoteWrite.enabled }}
        {{- $outputs = append $outputs "otelcol.connector.servicegraph.default.input" }}
        {{- end }}
        traces = [{{ join ", " $outputs }}]
      }
    }

    {{- if and (or .Values.alloyConfig.traces.spanMetrics.enabled .Values.alloyConfig.traces.serviceGraph.enabled) .Values.prometheusRemoteWrite.enabled }}
    otelcol.exporter.prometheus "trace_metrics" {
      forward_to = [{{ range $idx, $endpoint := .Values.prometheusRemoteWrite.endpoints }}{{ if $idx }}, {{ end }}prometheus.remote_write.endpoint_{{ $idx }}.receiver{{ end }}]
    }
    {{- end }}

    {{- if and .Values.alloyConfig.traces.spanMetrics.enabled .Values.prometheusRemoteWrite.enabled }}
    otelcol.connector.spanmetrics "default" {
      {{- range $dim := .Values.alloyConfig.traces.spanMetrics.dimensions }}
      dimension {
        name = {{ $dim | quote }}
      }
      {{- end }}
      dimension {
        name    = "error"
        default = "false"
      }

      histogram {
        explicit {
          buckets = [{{ range $idx, $bucket := .Values.alloyConfig.traces.spanMetrics.histogramBuckets }}{{ if $idx }}, {{ end }}{{ $bucket | quote }}{{ end }}]
        }
      }

      namespace = {{ .Values.alloyConfig.traces.spanMetrics.namespace | quote }}

      output {
        metrics = [otelcol.exporter.prometheus.trace_metrics.input]
      }
    }
    {{- end }}

    {{- if and .Values.alloyConfig.traces.serviceGraph.enabled .Values.prometheusRemoteWrite.enabled }}
    otelcol.connector.servicegraph "default" {
      dimensions = [{{ range $idx, $dim := .Values.alloyConfig.traces.serviceGraph.dimensions }}{{ if $idx }}, {{ end }}{{ $dim | quote }}{{ end }}]

      output {
        metrics = [otelcol.exporter.prometheus.trace_metrics.input]
      }
    }
    {{- end }}

    {{- range $idx, $endpoint := .Values.tempo.endpoints }}
    {{- if $endpoint.basicAuth }}
    otelcol.auth.basic "tempo_{{ $idx }}" {
      username = {{ $endpoint.basicAuth.username | quote }}
      password = {{ $endpoint.basicAuth.password | quote }}
    }
    {{- end }}

    {{- if eq ($endpoint.protocol | default "grpc") "http" }}
    otelcol.exporter.otlphttp "tempo_{{ $idx }}" {
      client {
        endpoint = {{ $endpoint.url | quote }}
        {{- if $endpoint.basicAuth }}
        auth = otelcol.auth.basic.tempo_{{ $idx }}.handler
        {{- end }}
        {{- if $endpoint.tls }}
        tls {
          insecure = {{ $endpoint.tls.insecure | default false }}
          {{- if $endpoint.tls.insecureSkipVerify }}
          insecure_skip_verify = {{ $endpoint.tls.insecureSkipVerify }}
          {{- end }}
        }
        {{- end }}
      }
    }
    {{- else }}
    otelcol.exporter.otlp "tempo_{{ $idx }}" {
      client {
        endpoint = {{ $endpoint.url | quote }}
        {{- if $endpoint.basicAuth }}
        auth = otelcol.auth.basic.tempo_{{ $idx }}.handler
        {{- end }}
        {{- if $endpoint.tls }}
        tls {
          insecure = {{ $endpoint.tls.insecure | default false }}
          {{- if $endpoint.tls.insecureSkipVerify }}
          insecure_skip_verify = {{ $endpoint.tls.insecureSkipVerify }}
          {{- end }}
        }
        {{- end }}
      }
    }
    {{- end }}
    {{- end }}
    {{- end }}
{{- end }}
{{- end }}
