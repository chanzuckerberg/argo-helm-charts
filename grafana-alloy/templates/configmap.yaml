{{- if .Values.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-alloy-config
  labels:
    {{- include "grafana-alloy.labels" . | nindent 4 }}
data:
  config.alloy: |
{{- if .Values.alloyConfig.content }}
{{- .Values.alloyConfig.content | nindent 4 }}
{{- else }}
    logging {
      level  = "info"
      format = "logfmt"
    }

    {{- if .Values.alloyConfig.podLogs.enabled }}
    discovery.kubernetes "pods" {
      role = "pod"
      selectors {
        role  = "pod"
        field = "spec.nodeName=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
      }
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action        = "replace"
        target_label  = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        action        = "replace"
        target_label  = "job"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_service"]
        target_label  = "service"
        regex         = "(.+)"
        action        = "replace"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_label_service"]
        target_label  = "service"
        regex         = "(.+)"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_workflowName"]
        target_label  = "workflowName"
        regex         = "(.+)"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_workflowVersion"]
        target_label  = "workflowVersion"
        regex         = "(.+)"
        action        = "replace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "__path__"
        separator     = "/"
        replacement   = "/var/log/pods/*$1/*.log"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_id"]
        action        = "replace"
        target_label  = "container_runtime"
        regex         = "^(\\S+):\\/\\/.+$"
        replacement   = "$1"
      }
    }

    loki.source.kubernetes "pod_logs" {
      targets    = discovery.relabel.pod_logs.output
      forward_to = [loki.process.pod_logs.receiver]
    }

    loki.process "pod_logs" {
      stage.match {
        selector = "{namespace=\"loki\",container=~\"promtail|alloy\"}"
        action   = "drop"
      }

      stage.cri {}

      stage.static_labels {
        values = {
          cluster  = {{ .Values.clusterName | quote }},
          exporter = "grafana-alloy",
        }
      }

      stage.replace {
        expression = "\\x1b\\[[0-9;]*m"
        replace    = ""
      }

      stage.regex {
        expression = "(?i)(?:^|[\\s\"'\\[{(,:=])(?P<level>\\b(?:trace|debug|info|warn|warning|error|fatal|critical|trc|dbg|inf|wrn|err|crt|ftl)\\b)(?:[\\s\"'\\]}),.:=]|$)"
      }

      stage.labels {
        values = {
          level = "",
        }
      }

      stage.match {
        selector = "{namespace=\"nginx-encrypted-ingress\",container=\"controller\"}"
        
        stage.regex {
          expression = "^\\S+ \\S+ \\S+ \\[[^\\]]+\\] \"(?P<verb>\\S+) (?P<uri>\\/[^\\s\\?\"]+)(?:\\?\\S*)? (?P<http_version>[^\"]+)\" (?P<status>\\d{3}) \\d+ \"[^\"]*\" \"[^\"]*\" \\d+ [\\d.]+ \\[(?P<destination>[^\\]]+)\\]"
        }

        stage.labels {
          values = {
            verb         = "",
            uri          = "",
            status       = "",
            http_version = "",
            destination  = "",
          }
        }
      }

      forward_to = [loki.write.endpoints.receiver]
    }

    loki.write "endpoints" {
      endpoint {
        url = {{ .Values.loki.local.url | quote }}
      }

      {{- if and .Values.centralLoki.enabled .Values.centralLoki.url }}
      endpoint {
        url = {{ .Values.centralLoki.url | quote }}
        headers = {
          "Authorization" = "Basic " + env({{ .Values.centralLoki.basicAuthEnvVar | quote }}),
        }
      }
      {{- end }}
    }
    {{- end }}

    {{- if .Values.alloyConfig.events.enabled }}
    loki.source.kubernetes_events "k8s_events" {
      forward_to = [loki.relabel.rename_namespace.receiver]
      log_format = "json"
      job_name   = "kubernetes-events"
    }

    loki.relabel "rename_namespace" {
      forward_to = [loki.process.add_event_labels.receiver]
      
      rule {
        source_labels = ["namespace"]
        action        = "replace"
        target_label  = "event_namespace"
      }
    }

    loki.process "add_event_labels" {
      stage.static_labels {
        values = {
          cluster  = {{ .Values.clusterName | quote }},
          exporter = "grafana-alloy",
        }
      }

      stage.json {
        expressions = {
          event_message   = "msg",
          event_reason    = "reason",
          event_type      = "type",
          event_count     = "count",
          event_kind      = "kind",
          event_host      = "sourcehost",
          event_component = "sourcecomponent",
        }
      }

      stage.labels {
        values = {
          event_reason    = "",
          event_type      = "",
          event_kind      = "",
          event_namespace = "",
          event_host      = "",
        }
      }

      stage.label_keep {
        values = ["job","cluster","exporter","level","event_message","event_reason","event_type","event_kind","event_namespace","event_host"]
      }

      forward_to = [loki.write.endpoints.receiver]
    }
    {{- end }}

    {{- if and .Values.alloyConfig.metrics.enabled .Values.prometheusRemoteWrite.enabled }}
    discovery.kubernetes "pods_metrics" {
      role = "pod"
    }

    discovery.relabel "pods_metrics" {
      targets = discovery.kubernetes.pods_metrics.targets

      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }

      rule {
        source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "job"
      }
    }

    prometheus.scrape "pods" {
      targets         = discovery.relabel.pods_metrics.output
      forward_to      = [prometheus.relabel.filter_metrics.receiver]
      scrape_interval = "1m"
      scrape_timeout  = "10s"
    }

    prometheus.relabel "filter_metrics" {
      forward_to = [prometheus.remote_write.default.receiver]

      rule {
        target_label = "cluster"
        replacement  = {{ .Values.clusterName | quote }}
      }

      {{- if .Values.prometheusRemoteWrite.endpoints }}
      {{- $firstEndpoint := index .Values.prometheusRemoteWrite.endpoints 0 }}
      {{- if $firstEndpoint.externalLabels }}
      {{- range $key, $value := $firstEndpoint.externalLabels }}
      rule {
        target_label = {{ $key | quote }}
        replacement  = {{ $value | quote }}
      }
      {{- end }}
      {{- end }}
      {{- end }}

      {{- if .Values.prometheusRemoteWrite.metricsFilter.enabled }}
      rule {
        source_labels = ["__name__"]
        regex         = {{ .Values.prometheusRemoteWrite.metricsFilter.regex | quote }}
        action        = "keep"
      }
      {{- end }}
    }
    {{- end }}

    {{- if .Values.prometheusRemoteWrite.enabled }}
    prometheus.remote_write "default" {
      {{- range $idx, $endpoint := .Values.prometheusRemoteWrite.endpoints }}
      endpoint {
        url = {{ $endpoint.url | quote }}
        
        {{- if $endpoint.queueConfig }}
        queue_config {
          max_samples_per_send = {{ $endpoint.queueConfig.maxSamplesPerSend }}
          batch_send_deadline  = {{ $endpoint.queueConfig.batchSendDeadline | quote }}
          min_shards           = {{ $endpoint.queueConfig.minShards }}
          max_shards           = {{ $endpoint.queueConfig.maxShards }}
          capacity             = {{ $endpoint.queueConfig.capacity }}
        }
        {{- end }}

        {{- if $endpoint.sigv4 }}
        {{- if $endpoint.sigv4.enabled }}
        sigv4 {
          region = {{ $endpoint.sigv4.region | quote }}
        }
        {{- end }}
        {{- end }}
      }
      {{- end }}

      {{- if .Values.prometheusRemoteWrite.endpoints }}
      {{- $firstEndpoint := index .Values.prometheusRemoteWrite.endpoints 0 }}
      {{- if $firstEndpoint.externalLabels }}
      external_labels = {
        {{- range $key, $value := $firstEndpoint.externalLabels }}
        {{ $key }} = {{ $value | quote }},
        {{- end }}
      }
      {{- end }}
      {{- end }}
    }
    {{- end }}
{{- end }}
{{- end }}
