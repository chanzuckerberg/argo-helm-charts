argus-config: {} # @schema description: Allows values for the argus-config Helm chart
# @schema type: object
# @schema description: defines a template that is used to create a analysisRun
# @schema additionalProperties: true
rolloutAnalysis:
  # @schema item: object
  # @schema itemProperties: {"templateName": {"type": "string", "description": " name of the AnalysisTemplate to use for the rollout analysis"}, "clusterScope": {"type": "boolean", "description": "Whether to look for the templateName at cluster scope or namespace scope."}}
  # @schema description: reference to a list of analysis templates to combine for an AnalysisRun
  templates: []
  # @schema item: object
  # @schema itemProperties: {"name": {"type": "string"}, "value": {"type": "string"}, "valueFrom": {"type": "object", properties: {"podTemplateHashValue": {"type": "string", "enum": ["Latest", "Stable"]}, "fieldRef": {"type":"object", "properties": {"fieldPath": {"type": "string"}}}}}}
  # @schema description: the arguments that will be added to the AnalysisRuns
  args: []
  # @schema type: object
  # @schema description: extra labels to add to the AnalysisRun
  analysisRunMetadata:
    # @schema type: object
    # @schema description: additional labels to add to the AnalysisRun
    labels: {}
    # @schema type: object
    # @schema description: additional annotations to add to the AnalysisRun
    annotations: {}
# @schema additionalProperties: true
rollout:
  # @schema description: Specifies the rollout strategy for the application.
  # @schema type: object
  # @schema default: blueGreen
  strategy:
    # @schema default: blueGreen
    blueGreen:
      # @schema type: string
      # @schema description: Name of the service that the rollout modifies as the active service.
      activeService: ""
      # @schema type: string
      # @schema description: Name of the service that the rollout modifies as the preview service.
      previewService: ""
      # @schema type: boolean
      # @schema description: indicates if the rollout should automatically promote the new ReplicaSet to the active service or enter a paused state.
      autoPromotionEnabled: false
      # @schema $ref: #/properties/rolloutAnalysis
      # @schema description: configuration to run analysis before a selector switch
      prePromotionAnalysis: {}

global: # @schema description: Global configuration for the stack - this serves as the default configuration for all services/jobs/cronjobs
  # @schema description: Specifies the Kubernetes Kind for the main application workload controller (Deployment or Rollout).
  # @schema type: string
  # @schema enum:[Deployment, Rollout]
  # @schema default: Deployment
  deploymentKind: "Deployment"
  # @schema $ref: #/properties/rollout
  rollout: {} 
  deploymentStage: "" # @schema description: Deployment stage

  replicaCount: 1 # @schema description: Number of replicas

  # Settings for the primary container
  image:
    repository: nginx # @schema description: Image repository
    pullPolicy: IfNotPresent # @schema enum: [Always, IfNotPresent, Never]; description: Image pull policy
    tag: "latest" # @schema description: Image tag

  command: [] # @schema type: array; item: string; description: Command to run in the primary container
  args: [] # @schema type: array; item: string; description: Arguments to pass to the command in the primary container

  imagePullSecrets: [] # @schema type: array; item: string
  nameOverride: "" # @schema description: Name to prefix the K8s resources with, combined with the stack name prefix
  fullnameOverride: "" # @schema description: Name to prefix the K8s resources with, replaces the stack name prefix

  dnsPolicy: ClusterFirst # @schema enum: [ClusterFirst, Default, None]; description: DNS policy for the pod
  restartPolicy: Always # @schema enum: [Always, OnFailure, Never]; description: Restart policy for the pod

  # Probes for the primary container
  livenessProbe: # @schema description: Liveness probe configuration
    failureThreshold: 3 # @schema type: number; description: Number of failures before the probe is considered failed
    httpGet: # @schema description: HTTP probe configuration (exec & tcpSocket are also available)
      path: / # @schema description: Path to probe
      port: http # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: Port to probe
      scheme: HTTP # @schema description: Scheme to use
    periodSeconds: 10 # @schema type: number; description: How often to perform the probe
    successThreshold: 1 # @schema type: number; description: Number of successes before the probe is considered successful
    timeoutSeconds: 1 # @schema type: number; description: Timeout for the probe
    initialDelaySeconds: 30 # @schema type: number; description: Number of seconds after the container has started before the probe is first initiated
  
  readinessProbe: # @schema description: Readiness probe configuration
    failureThreshold: 3 # @schema type: number; description: Number of failures before the probe is considered failed
    httpGet: # @schema description: HTTP probe configuration (exec & tcpSocket are also available)
      path: / # @schema description: Path to probe
      port: http # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: Port to probe
      scheme: HTTP # @schema description: Scheme to use
    periodSeconds: 10 # @schema type: number; description: How often to perform the probe
    successThreshold: 1 # @schema type: number; description: Number of successes before the probe is considered successful
    timeoutSeconds: 1 # @schema type: number; description: Timeout for the probe
    initialDelaySeconds: 30 # @schema type: number; description: Number of seconds after the container has started before the probe is first initiated
  
  startupProbe: # @schema description: Startup probe configuration
    enabled: false # @schema description: Enable the startup probe
    failureThreshold: 3 # @schema description: Number of failures before the probe is considered failed
    successThreshold: 1 # @schema description: Number of successes before the probe is considered successful
    initialDelaySeconds: 0 # @schema description: Number of seconds after the container has started before the probe is first initiated
    timeoutSeconds: 1 # @schema description: Timeout for the probe
    periodSeconds: 10 # @schema description: How often to perform the probe
    ## Probe configuration (httpGet & tcpSocket are also available)
    exec: # @schema description: Exec probe configuration
      command: 
        - ps
        - "-ef"

  progressDeadlineSeconds: 600 # @schema description: the number of seconds the Deployment controller waits before indicating (in the Deployment status) that the Deployment progress has stalled

  resources: # @schema description: Resource requests and limits for the primary container
    limits: # @schema description: Resource limits
      cpu: "1" # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: CPU limit
      memory: "1Gi" # @schema description: Memory limit
    requests: # @schema description: Resource requests
      cpu: "100m" # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: CPU request
      memory: "128Mi" # @schema description: Memory request

  service: # @schema description: Service configuration
    type: ClusterIP # @schema description: Service type
    port: 80 # @schema type: number; description: Service port

  initContainers: [] # @schema type: array; description: List of init containers
  sidecars: [] # @schema type: array; description: List of sidecars

  ## @skip App context (provided by Argus API)
  appContext:
    ## @skip global.appContext.envContextConfigMapName App environment level configuration configmap name
    envContextConfigMapName: ""
    ## @skip global.appContext.stackContextConfigMapName Stack level configuration configmap name
    stackContextConfigMapName: ""

  ## @skip App secrets (provided by Argus API)
  appSecrets:
    envSecret:
      ## @skip global.appSecrets.envSecret.secretName Environment-level Kube secret name to write External Secrets to
      secretName: ""
      ## @skip global.appSecrets.envSecret.secretKey Environment-level secret key to map External Secrets from
      secretKey: ""
    stackSecret:
      ## @skip global.appSecrets.stackSecret.secretName Stack-level Kube secret name to write External Secrets to
      secretName: ""
      ## @skip global.appSecrets.stackSecret.secretKey Stack-level secret key to map External Secrets from
      secretKey: ""
    clusterSecret:
      ## @skip global.appSecrets.clusterSecret.secretName Cluster-level Kube secret name to write External Secrets to
      secretName: ""
      ## @skip global.appSecrets.clusterSecret.secretKey Cluster-level secret key to map External Secrets from
      secretKey: ""

  # @schema description: Argo built-in environment parameters (provided by Argus API)
  argoBuildEnv:
    appName: "" # @schema description: Set by Argus API to ARGOCD_APP_NAME (this is the ArgoCD app name, not the Argus app name)
    appNamespace: "" # @schema description: Set by Argus API to ARGOCD_APP_NAMESPACE
    appRevision: "" # @schema description: Set by Argus API to ARGOCD_APP_REVISION
    appRevisionShort: "" # @schema description: Set by Argus API to ARGOCD_APP_REVISION_SHORT
    appRevisionShort8: "" # @schema description: Set by Argus API to ARGOCD_APP_REVISION_SHORT_8
    appSourcePath: "" # @schema description: Set by Argus API to ARGOCD_APP_SOURCE_PATH
    appSourceRepoUrl: "" # @schema description: Set by Argus API to ARGOCD_APP_SOURCE_REPO_URL
    appSourceTargetRevision: "" # @schema description: Set by Argus API to ARGOCD_APP_SOURCE_REPO_URL

  # @schema description: Argus metadata (provided by Argus API)
  argusMetadata:
    appName: "" # @schema description: Set by Argus API to Argus app name
    envName: "" # @schema description: Set by Argus API to Argus environment name
    stackName: "" # @schema description: Set by Argus API to Argus stack name
    repoName: "" # @schema description: Set by Argus API to Argus repository name
    repoOwner: "" # @schema description: Set by Argus API to Argus repository owner

  annotations: {} # @schema description: Global annotations to add to all resources
  podLabels: {} # @schema description: Global labels to add to all pods

  serviceAccount: # @schema description: Service account configuration
    create: false # @schema description: Specifies whether a service account should be created
    automount: true # @schema description: Specifies whether to automatically mount a ServiceAccount's API credentials
    annotations: {} # @schema description: Annotations to add to the service account
    name: "" # @schema description: Name of the service account to use (if not set and create is true, a name is generated using the fullname template)

  podSecurityContext: # @schema description: Pod security context
    {}
    # fsGroup: 2000

  securityContext: # @schema description: Security context
    {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  shareProcessNamespace: false # @schema description: Share process namespace

  ingress: # @schema description: Ingress configuration
    enabled: true # @schema description: Enable ingress
    className: nginx # @schema description: Ingress class name
    host: chart-example.local # @schema description: Ingress host
    paths: # @schema description: List of ingress paths
      - 
        path: / # @schema description: Ingress path
        pathType: Prefix # @schema description: Ingress path type
    rules: [] # @schema description: List of ingress rules
    oidcProtected: false # @schema description: Enable OIDC protection
    annotations:
      nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
      nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
      nginx.ingress.kubernetes.io/affinity: "cookie"
      nginx.ingress.kubernetes.io/session-cookie-name: "argus_sticky_session"
      nginx.ingress.kubernetes.io/session-cookie-max-age: "600"
    tls: [] # @schema description: List of ingress TLS configurations
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  
  nodeSelector:
    kubernetes.io/arch: arm64 # @schema description: Node selector for architecture

  podAnnotations: # @schema type: object; description: Annotations to add to pods
    {}
    
  autoscaling: # @schema description: Autoscaling configuration
    enabled: true # @schema description: Enable autoscaling
    minReplicas: 1 # @schema description: Minimum number of replicas
    maxReplicas: 10 # @schema description: Maximum number of replicas
    targetCPUUtilizationPercentage: 80 # @schema description: Target CPU utilization percentage
    targetMemoryUtilizationPercentage: 80 # @schema description: Target memory utilization percentage

  volumes: [] # @schema description: Additional volumes on the output Deployment definition
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  volumeMounts: [] # @schema description: Additional volume mounts on the output Deployment definition
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  tolerations: [] # @schema description: Tolerations for the pod

  affinity: {} # @schema description: Affinity for the pod

  topologySpreadConstraints: [] # @schema description: Topology spread constraints for the pod

  env: [] # @schema type: array; item: object; itemProperties: {"name": {"type": "string"}, "value": {"type": "string"}}

  envFrom: [] # @schema type: array; item: object; itemProperties: {"configMapRef": {"type": "object"}, "secretRef": {"type": "object"}, "prefix": {"type": "string"}}; description: Environment variables from configmaps or secrets

  persistence:
    enabled: false # @schema description: Enable persistence
    pvc:
      accessModes: # @schema type: array; item: string; itemEnum: [ReadWriteOnce, ReadOnlyMany, ReadWriteMany, ReadWriteOncePod]; description: Access modes for the PVC
        - ReadWriteOnce
      resources:
        requests: # @schema description: PVC resource requests
          storage: 8Gi # @schema description: Storage resource request
      storageClassName: "default" # @schema description: Storage class name
      dataSource:
        name: "" # @schema description: Name of the data source
        kind: "" # @schema description: Kind of the data source [VolumeSnapshot, PersistentVolumeClaim]
        apiGroup: "snapshot.storage.k8s.io/v1" # @schema description: API version of the data source
    existingClaim: "" # @schema description: Existing PVC name
    mountPath: "" # @schema description: Mount path for the PVC

  s3Storage:
    enabled: false # @schema description: Enable S3 CSI storage
    bucketName: "" # @schema description: S3 bucket name
    region: "us-west-2" # @schema description: AWS region
    capacity: "5Gi" # @schema description: Storage capacity
    accessModes: # @schema type: array; item: string; itemEnum: [ReadWriteOnce, ReadOnlyMany, ReadWriteMany, ReadWriteOncePod]; description: Access modes for the S3 storage
      - ReadWriteMany
    reclaimPolicy: "Retain" # @schema description: Reclaim policy for the PV
    pvName: "" # @schema description: Custom PV name (auto-generated if empty)
    pvcName: "" # @schema description: Custom PVC name (auto-generated if empty)
    volumeHandle: "" # @schema description: CSI volume handle (auto-generated if empty)
    labels: {} # @schema type: object; description: Additional labels for PV/PVC
    annotations: {} # @schema type: object; description: Additional annotations for PV/PVC
    volumeAttributes: {} # @schema type: object; description: Additional CSI volume attributes

  oidcProxy:
    enabled: false # @schema description: Enable OIDC proxy
    image:
      repository: quay.io/oauth2-proxy/oauth2-proxy # @schema description: Image repository
      tag: v7.6.0 # @schema description: Image tag
    replicaCount: 3 # @schema description: Number of replicas
    additionalSecrets: [] # @schema description: Additional secrets to mount
    additionalHeaders: [] # @schema description: Additional headers to add
    annotations: {} # @schema type: object; description: Annotations to add to the OIDC proxy
    volumeMounts: [] # @schema description: Volume mounts for the OIDC proxy
    skipAuth: [] # @schema type: array; item: object; itemProperties: {"path": {"type": "string"}, "method": {"type": "string"}}; description: Paths to skip authentication
    # skipAuth:
    #   - path: "/healthz"
    #     method: GET
    cookieRefresh: "59m" # @schema description: Refresh tokens and cookies after this period
    extraArgs: [] # @schema type: array; item: string; description: Extra arguments to pass to the OIDC proxy
    # extraArgs:
    #   - --flag
    #   - --another-flag=2
    resources:
      limits:
        cpu: "2" # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: CPU limit
        memory: 4Gi # @schema description: Memory limit
      requests:
        cpu: 2 # @schema oneOf: [{ "type": "string" },{ "type": "number" }]; description: CPU request
        memory: 4Gi # @schema description: Memory request

  grafanaDashboard:
    enabled: true # @schema description: Enable Grafana dashboard (globally, can be overridden per service)
    datasources:
      prometheus:
        uid: "amp" # @schema description: Prometheus datasource UID
    instanceSelector: # @schema description: Instance selector for the Grafana dashboard
      matchLabels:
        name: central-grafana
    extraPanels: [] # @schema type: array; item: object; itemProperties: {"type": {"type": "string"}, "title": {"type": "string"}, "datasource": {"type": "object"}, "targets": {"type": "array"}, "gridPos": {"type": "object"}, "options": {"type": "object"}}; description: Extra panels to add to the Grafana dashboard
    # extraPanels:
    #   - type: timeseries
    #     title: "Extra Panel"
    #     datasource:
    #       type: "prometheus"
    #       uid: "amp"
    #     targets:
    #       - expr: "up"
    #     gridPos: {"h": 10, "w": 12, "x": 0, "y": 0}
    #     options: {"legend": {"displayMode": "list", "placement": "bottom", "showLegend": true}}

services: # @schema patternProperties: { "^.*$": {"$ref": "#/properties/global", "type": "object", "unevaluatedProperties": false } }; description: Services to deploy
  {}
  # service1:
  #   args: ["arg1", "arg2"]
  #   command: ["command1", "command2"]
  #   serviceAccount:
  #     create: true
  #   autoscaling:
  #     enabled: true
  #     minReplicas: 2
  #     maxReplicas: 10
  #     maxUnavailable: 1
  #   replicaCount: 2
  #   sidecars:
  #     - name: sidecar1
  #       image: "sidecar1:latest"
  #     - name: sidecar2
  #       image: "sidecar2:latest"
  #   initContainers:
  #     - name: initContainer1
  #       image: "alpine:latest"
  #       command: ["echo", "Hello World"]
  # service2:
  #   startupProbe:
  #     enabled: true
  #   autoscaling:
  #     enabled: true
  #     minReplicas: 2
  #     maxReplicas: 10
  #     maxUnavailable: 1
  #   replicaCount: 2
  #   sidecars:
  #     - name: sidecar3
  #       image: sidecar3:latest
  #     - name: sidecar4
  #       image: sidecar4:latest

cronJobs: # @schema patternProperties: { "^.*$": {"$ref": "#/properties/global", "type": "object" } }; description: Cron jobs to deploy
  {}
  # cronJob1:
  #   concurrencyPolicy: Forbid
  #   schedule: "* * * * *"
  #   serviceAccount:
  #     create: true
  #   image:
  #     repository: nginx
  #     pullPolicy: IfNotPresent
  #     tag: "latest"
  #   command: ["command1", "command2"]
  #   args: ["arg1", "arg2"]

jobs: # @schema patternProperties: { "^.*$": {"$ref": "#/properties/global", "type": "object" } }; description: Jobs to deploy
  {}
  # job1:
  #   activeDeadlineSeconds: 300
  #   backoffLimit: 2
  #   completions: 5
  #   parallelism: 3
  #   serviceAccount:
  #     create: true
  #     annotations:
  #       "eks.amazonaws.com/role-arn": some-role
  #   image:
  #     repository: my-repo
  #     tag: sha-mytag
  #   command: ["hello-world"]
  #   args: ["arg1", "arg2"]
